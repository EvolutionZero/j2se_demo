package com.zero.j2se.demo;

import java.util.WeakHashMap;

/**
 * JVM的体系结构:
 * （1）java栈内存，它等价于C语言中的栈， 栈的内存地址是不连续的， 每个线程都拥有自己的栈。 栈里面存储着的是StackFrame，在《JVM Specification》中文版中被译作java虚拟机框架，也叫做栈帧。
 *     StackFrame包含三类信息:局部变量，执行环境，操作数栈。局部变量用来存储一个类的方法中所用到的局部变量。执行环境用于保存解析器对于java字节码进行解释过程中需要的信息，包括:上次调用的方法、局部变量指针和 操作数栈的栈顶和栈底指针。
 *     操作数栈用于存储运算所需要的操作数和结果。StackFrame在方法被调用时创建，在某个线程中，某个时间点上，只有一个 框架是活跃的，该框架被称为Current Frame，而框架中的方法被称为Current Method，其中定义的类为Current Class。
 *     局部变量和操作数栈上的操作总是引用当前框架。当Stack Frame中方法被执行完之后，或者调用别的StackFrame中的方法时，则当前栈变为另外一个StackFrame。Stack的大小是由两种类 型，固定和动态的，动态类型的栈可以按照线程的需要分配。
 * （2） Java堆是用来存放对象信息的，和Stack不同，Stack代表着一种运行时的状态。换句话说，栈是运行时单位，解决程序该如何执行的问题，而堆是存储的单位， 解决数据存储的问题。Heap是伴随着JVM的启动而创建，负责存储所有对象实例和数组的。堆的存储空间和栈一样是不需要连续的。
 * （3）程序计数寄存器，程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。
 *     在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
 * （4）方法区域（Method Area），在Sun JDK中这块区域对应的为PermanetGeneration，又称为持久代。
 *     方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，
 *     这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。
 * （5）运行时常量池（Runtime Constant Pool），存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。
 * （6）本地方法堆栈（Native Method Stacks），JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。
 * 
 * 
 */
public class LearnJMM {
	
	/**
	 * 1.Java堆内存
 	 * 新生代:新生代由 Eden 与 Survivor Space（S0(from)，S1(to)）构成，大小通过-Xmn参数指定，Eden 与 Survivor Space 的内存大小比例默认为8:2，可以通过-XX:SurvivorRatio 参数指定，比如新生代为10M 时，Eden分配8M，S0和S1各分配1M。
	 *  	Eden    :大多数情况下，对象在Eden中分配，当Eden没有足够空间时，会触发一次Minor GC，虚拟机提供了-XX:+PrintGCDetails参数，告诉虚拟机在发生垃圾回收时打印内存回收日志。
	 *      Survivor:意思为幸存者，是新生代和老年代的缓冲区域。当新生代发生GC（Minor GC）时，会将存活的对象移动到S0内存区域，并清空Eden区域，当再次发生Minor GC时，将Eden和S0中存活的对象移动到S1内存区域。
	 *      移动到老年代条件:存活对象会反复在S0和S1之间移动，当对象从Eden移动到Survivor或者在Survivor之间移动时，对象的GC年龄自动累加，当GC年龄超过默认阈值15时，会将该对象移动到老年代，可以通过参数-XX:MaxTenuringThreshold 对GC年龄的阈值进行设置。
	 *      
	 * 老年代:老年代的空间大小即-Xmx 与-Xmn 两个参数之差，用于存放经过几次Minor GC之后依旧存活的对象。当老年代的空间不足时，会触发Major GC/Full GC，速度一般比Minor GC慢10倍以上。
	 * 
	 * 永久代:类的元数据如方法数据、方法信息（字节码，栈和变量大小）、运行时常量池、已确定的符号引用和虚方法表等被保存在永久代中，32位默认永久代的大小为64M，64位默认为85M，可以通过参数-XX:MaxPermSize进行设置，一旦类的元数据超过了永久代大小，就会抛出OOM异常。
	 *      
	 * 元空间:虚拟机团队在JDK8的HotSpot中，把永久代从Java堆中移除了，并把类的元数据直接保存在本地内存区域（堆外内存），称之为元空间。
	 *      对永久代的调优过程非常困难，永久代的大小很难确定，其中涉及到太多因素，如类的总数、常量池大小和方法数量等，而且永久代的数据可能会随着每一次Full GC而发生移动。
	 *      而在JDK8中，类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间，可以避免永久代的内存溢出问题，不过需要监控内存的消耗情况，一旦发生内存泄漏，会占用大量的本地内存。
	 *      JDK7之前的HotSpot，字符串常量池的字符串被存储在永久代中，因此可能导致一系列的性能问题和内存溢出错误。在JDK8中，字符串常量池中只保存字符串的引用。
	 *      
	 *      
	 * 2.如何判断对象是否存活
	 * 引用计数法:在对象上添加一个引用计数器，每当有一个对象引用它时，计数器加1，当使用完该对象时，计数器减1，计数器值为0的对象表示不可能再被使用。引用计数法实现简单，判定高效，但不能解决对象之间相互引用的问题。
	 * 可达性分析法:通过一系列称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，搜索路径称为 “引用链”，以下对象可作为GC Roots：本地变量表中引用的对象、方法区中静态变量引用的对象、方法区中常量引用的对象、Native方法引用的对象。
	 *          当一个对象到 GC Roots 没有任何引用链时，意味着该对象可以被回收。在可达性分析法中，判定一个对象objA是否可回收，至少要经历两次标记过程：
	 *          1.如果对象objA到 GC Roots没有引用链，则进行第一次标记。
	 *          2.如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法。
	 *            finalize()方法是对象逃脱死亡的最后机会，GC会对队列中的对象进行第二次标记，如果objA在finalize()方法中与引用链上的任何一个对象建立联系，那么在第二次标记时，objA会被移出“即将回收”集合。
	 */
	public static void learnGC() {
		/**
		 * 
		 * 通知JVM执行gc，不一定立即执行
		 * 
		 * 触发GC的条件：
		 * 1.GC在优先级最低的线程中运行，一般在应用程序空闲即没有应用线程在运行时被调用
		 * 2.Java堆内存不足时，GC会被调用
		 * 
		 * 收集算法：
		 * 1.标记-清除算法:对待回收的对象进行标记。标记和清除过程效率都很低，收集之后会产生大量的内存碎片，不利于大对象的分配。
		 * 2.复制算法:将可用内存划分成大小相等的两块A和B，每次只使用其中一块，当A的内存用完了，就把存活的对象复制到B，并清空A的内存，不仅提高了标记的效率，因为只需要标记存活的对象，同时也避免了内存碎片的问题，代价是可用内存缩小为原来的一半。
		 * 3.标记-整理算法:在老年代中，对象存活率较高，复制算法的效率很低。在标记-整理算法中，标记出所有存活的对象，并移动到一端，然后直接清理边界以外的内存。
		 * 4.分代收集算法:根据各个年代的特点采用不同的收集算法。
		 *   新生代中的对象“朝生夕死”，每次GC时都会有大量对象死去，少量存活，使用复制算法。新生代又分为Eden区和Survivor区（Survivor from、Survivor to），大小比例默认为8:1:1。
		 *   老年代中的对象因为对象存活率高、没有额外空间进行分配担保，就使用标记-清除或标记-整理算法。
		 *   1)新产生的对象优先进去Eden区，当Eden区满了之后再使用Survivor from，当Survivor from 也满了之后就进行Minor GC（新生代GC），将Eden和Survivor from中存活的对象copy进入Survivor to，
		 *     然后清空Eden和Survivor from，这个时候原来的Survivor from成了新的Survivor to，原来的Survivor to成了新的Survivor from。
		 *     复制的时候，如果Survivor to 无法容纳全部存活的对象，则根据老年代的分配担保（类似于银行的贷款担保）将对象copy进去老年代，如果老年代也无法容纳，则进行Full GC（老年代GC）。
		 *   2)大对象直接进入老年代：JVM中有个参数配置-XX:PretenureSizeThreshold，令大于这个设置值的对象直接进入老年代，目的是为了避免在Eden和Survivor区之间发生大量的内存复制。
		 *   3)长期存活的对象进入老年代：JVM给每个对象定义一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移入Survivor并且年龄设定为1。
		 *     每熬过一次Minor GC，年龄就加1，当他的年龄到一定程度（默认为15岁，可以通过XX:MaxTenuringThreshold来设定），就会移入老年代。
		 *     但是JVM并不是永远要求年龄必须达到最大年龄才会晋升老年代，如果Survivor 空间中相同年龄（如年龄为x）所有对象大小的总和大于Survivor的一半，年龄大于等于x的所有对象直接进入老年代，无需等到最大年龄要求。
		 * 
		 * 标记过程：
		 *    在可达性分析过程中，为了准确找出与GC Roots相关联的对象，必须要求整个执行引擎看起来像是被冻结在某个时间点上，即暂停所有运行中的线程，不可以出现对象的引用关系还在不断变化的情况。
		 *    GC Roots主要在全局性的引用（常量或类静态属性）与执行上下文（本地变量表中的引用）中，很多应用仅仅方法区就上百兆，如果进行遍历查找，效率会非常低下。
		 *    在HotSpot中，使用一组称为OopMap的数据结构进行实现。类加载完成时，HotSpot把对象内什么偏移量上是什么类型的数据计算出来存储到OopMap中，通过JIT编译出来的本地代码，也会记录下栈和寄存器中哪些位置是引用。GC发生时，通过扫描OopMap的数据就可以快速标识出存活的对象。
		 *    
		 * 垃圾收集器:
		 * 1.Serial收集器（串行GC）,是一个采用单个线程并基于复制算法工作在新生代的收集器，进行垃圾收集时，必须暂停其他所有的工作线程，即“Stop the World”。对于单CPU环境来说，Serial由于没有线程交互的开销，可以很高效的进行垃圾收集动作，是Client模式下新生代默认的收集器
		 * 2.ParNew收集器（并行GC）,其实是serial的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial一样。是许多运行在Server模式下的JVM中首选的新生代收集器，其中一个很重还要的原因就是除了Serial之外，只有他能和老年代的CMS收集器配合工作。
		 * 3.Parallel Scavenge收集器（并行回收GC）,是一个采用多线程基于复制算法并工作在新生代的收集器，其关注点在于达到一个可控的吞吐量，经常被称为“吞吐量优先”的收集器。这样可以高效率的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。
		 *   吞吐量 = 用户代码运行时间 /（用户代码运行时间 + 垃圾收集时间）	
         *   Parallel Scavenge提供了两个参数用于精确控制吞吐量：
         *   -XX：MaxGCPauseMillis 设置垃圾收集的最大停顿时间
         *   -XX：GCTimeRatio 设置吞吐量大小
         * 4.Serial Old收集器（串行GC）, 是一个采用单线程基于标记-整理算法并工作在老年代的收集器，是Client模式下老年代默认的收集器。
         * 5.Parallel Old收集器（并行GC）,是一个采用多线程基于标记-整理算法并工作在老年代的收集器。在注重吞吐量以及CPU资源敏感的场合，可以优先考虑Parallel Scavenge和Parallel Old的收集器组合。
         * 6.CMS(Concurrent Mark Sweep)收集器（并发GC）,是一种以获取最短回收停顿时间为目标的收集器，工作在老年代，基于“标记-清除”算法实现，整个过程分为以下4步：
         *   初始标记：这个过程只是标记以下GC Roots能够直接关联的对象，但是仍然会Stop The World；
         *   并发标记：进行GC Roots Tracing的过程，可以和用户线程一起工作。
         *   重新标记：用于修正并发标记期间由于用户程序继续运行而导致标记产生变动的那部分记录，这个过程会暂停所有线程，但其停顿时间远比并发标记的时间短；
         *   并发清理：可以和用户线程一起工作。
         *   
         *   优点:
         *   由于整个过程耗时最长的并发标记和并发清除都可以和用户线程一起工作，所以总体上来看，CMS收集器的内存回收过程和用户线程是并发执行的。
         *   
         *   缺点：
         *   对CPU资源比较敏感，在并发阶段，虽然不会导致用户线程停顿，但是会占用一部分线程资源，降低系统的总吞吐量;
         *   CMS的默认收集线程数量是=(CPU数量+3)/4；当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。
         *   无法处理浮动垃圾(在并发清理阶段，用户线程的运行依然会产生新的垃圾对象),这部分垃圾只能在下一次GC时收集,可能出现"Concurrent Mode Failure"失败;
         *   CMS是基于标记-清除算法实现的，意味着收集结束后会造成大量的内存碎片，可能导致出现老年代剩余空间很大，却无法找到足够大的连续空间分配当前对象，不得不提前触发一次Full GC;
         *   并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集；如果CMS预留内存空间无法满足程序需要，就会出现一次"Concurrent Mode Failure"失败；这时JVM启用后备预案：临时启用Serail Old收集器，而导致另一次Full GC的产生;
         *   
         * 7.G1收集器,是JDK1.7提供的一个工作在新生代和老年代的收集器，基于“标记-整理”算法实现，在收集结束后可以避免内存碎片问题。
         *   使用G1收集器时，Java堆的内存布局与其他收集器有很大区别，整个Java堆会被划分为多个大小相等的独立区域Region，新生代和老年代不再是物理隔离了，都是一部分Region（不需要连续）的集合。
         *   G1会跟踪各个Region的垃圾收集情况（回收空间大小和回收消耗的时间），维护一个优先列表，根据允许的收集时间，优先回收价值最大的Region，避免在整个Java堆上进行全区域的垃圾回收，确保了G1收集器可以在有限的时间内尽可能收集更多的垃圾。
         *   优点如下：
         *   并行与并发：充分利用多CPU来缩短Stop The World的停顿时间；
         *   分代收集：不需要其他收集配合就可以管理整个Java堆，采用不同的方式处理新建的对象、已经存活一段时间和经历过多次GC的对象获取更好的收集效果;
         *   空间整合：与CMS的”标记-清除”算法不同，G1在运行期间不会产生内存空间碎片，有利于应用的长时间运行，且分配大对象时，不会导致由于无法申请到足够大的连续内存而提前触发一次Full GC;
         *   停顿预测：G1中可以建立可预测的停顿时间模型，能让使用者明确指定在M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。  
         *
		 * 
		 */
		System.gc();
	}
	
	public void useClassLoader() {
		/**
		 * 
		 * 类从被加载到虚拟机内存中开始，到卸载出内存，它的整个生命周期包括：
		 * 加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initiallization）、使用（Using）和卸载（Unloading）这7个阶段。
		 * 其中验证、准备、解析3个部分统称为连接（Linking）。
		 * 
		 * 加载(Loading)：
		 *  有两种时机会触发类加载：
		 *  1)预加载。虚拟机启动时加载，加载的是JAVA_HOME/lib/下的rt.jar下的.class文件，这个jar包里面的内容是程序运行时非常常常用到的，像java.lang.*、java.util.*、java.io.*等等，因此随着虚拟机一起加载。
		 *    要证明这一点很简单，写一个空的main函数，设置虚拟机参数为"-XX:+TraceClassLoading"来获取类加载信息。
		 *  2)运行时加载。虚拟机在用到一个.class文件的时候，会先去内存中查看一下这个.class文件有没有被加载，如果没有就会按照类的全限定名来加载这个类。
		 * 
		 *  加载阶段做了三件事:
		 *  1.获取.class文件的二进制流
		 *  2.将类信息、静态变量、字节码、常量这些.class文件中的内容放入方法区中
		 *  3.在内存中生成一个代表这个.class文件的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。一般这个Class是在堆里的，不过HotSpot虚拟机比较特殊，这个Class对象是放在方法区中的
		 *  
		 *  二进制字节流来源:
		 *  1.从zip包中获取，这就是以后jar、ear、war格式的基础
		 *  2.从网络中获取，典型应用就是Applet
		 *  3.运行时计算生成，典型应用就是动态代理技术
		 *  4.由其他文件生成，典型应用就是JSP，即由JSP生成对应的.class文件
		 *  5.从数据库中读取，这种场景比较少见
		 * 
		 * 验证（Verification）:
		 *    这一阶段的目的是为了确保.class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
		 *    Java语言本身是相对安全的语言（相对C/C++来说），但是前面说过，.class文件未必要从Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生.class文件。在字节码语言层面上，Java代码至少从语义上是可以表达出来的。
		 *    虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。
		 *  验证阶段将做以下几个工作：
		 *  1.文件格式检查。class文件的第5~第8个字节表示的是该.class文件的主次版本号，验证的时候会对这4个字节做一个验证，高版本的JDK能向下兼容以前版本的.class文件，但不能运行以后的class文件，即使文件格式未发生任何变化，虚拟机也必须拒绝执行超过其版本号的.class文件。
		 *  2.元数据验证
		 *  3.字节码验证
		 *  4.符号引用验证
		 * 
		 * 准备（Preparation）:
		 *    准备阶段是正式为类变量分配内存并设置其初始值的阶段，这些变量所使用的内存都将在方法区中分配。关于这点，有两个地方注意一下：
		 *    1.这时候进行内存分配的仅仅是类变量（被static修饰的变量），而不是实例变量，实例变量将会在对象实例化的时候随着对象一起分配在Java堆中
		 *    2.这个阶段赋初始值的变量指的是那些不被final修饰的static变量，
		 *      比如"public static int value = 123;"，value在准备阶段过后是0而不是123，给value赋值为123的动作将在初始化阶段才进行；
		 *      比如"public static final int value = 123;"就不一样了，在准备阶段，虚拟机就会给value赋值为123。
		 * 
		 * 解析（Resolution）:
		 *    解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
		 *    符号引用是属于编译原理方面的概念，符号引用包括了下面三类常量：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。符号引用和虚拟机的内存布局是没有关系的，引用的目标未必已经加载到内存中了。
		 *    直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机示例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经存在在内存中了。
		 * 
		 * 初始化（Initiallization）:
		 *    初始化阶段是类加载过程的最后一步，初始化阶段是真正执行类中定义的Java程序代码（或者说是字节码）的过程。初始化过程是一个执行类构造器<clinit>()方法的过程，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。
		 * 把这句话说白一点，其实初始化阶段做的事就是给static变量赋予用户指定的值以及执行静态代码块。
		 *    注意一下，虚拟机会保证类的初始化在多线程环境中被正确地加锁、同步，即如果多个线程同时去初始化一个类，那么只会有一个类去执行这个类的<clinit>()方法，其他线程都要阻塞等待，直至活动线程执行<clinit>()方法完毕。
		 * 因此如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞。不过其他线程虽然会阻塞，但是执行<clinit>()方法的那条线程退出<clinit>()方法后，其他线程不会再次进入<clinit>()方法了，因为同一个类加载器下，一个类只会初始化一次。
		 * 实际应用中这种阻塞往往是比较隐蔽的，要小心。
		 *   Java虚拟机规范严格规定了有且只有5种场景必须立即对类进行初始化，这5种场景也称为对一个类进行主动引用:
		 *   1.使用new关键字实例化对象、读取或者设置一个类的静态字段（被final修饰的静态字段除外）、调用一个类的静态方法的时候
		 *   2.使用java.lang.reflect包中的方法对类进行反射调用的时候
		 *   3.初始化一个类，发现其父类还没有初始化过的时候
		 *   4.虚拟机启动的时候，虚拟机会先初始化用户指定的包含main()方法的那个类
		 *   5.当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic等时
		 *   除了上面5种场景外，所有引用类的方式都不会触发类的初始化，称为被动引用，接下来看下被动引用的几个例子：
		 *   1.子类引用父类静态字段，不会导致子类初始化。至于子类是否被加载、验证了，前者可以通过"-XX:+TraceClassLoading"来查看
		 *   2.通过数组定义引用类，不会触发此类的初始化
		 *   3.引用静态常量时，常量在编译阶段会存入类的常量池中，本质上并没有直接引用到定义常量的类
		 *    
		 * 类加载器： 用户自定义加载器->应用程序加载器->扩展类加载器->启动类加载器。 
		 * 启动（Bootstrap）类加载器：
		 *    启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，
		 * 注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。   
		 * 
		 * 扩展（Extension）类加载器：
		 *    扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，
		 * 开发者可以直接使用标准扩展类加载器。
		 *    
		 * 系统（System）类加载器：
		 *    也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，
		 * 一般情况下该类加载是程序中默认的类加载器，通过ClassLoader.getSystemClassLoader()方法可以获取到该类加载器。 
		 * 
		 * 双亲委派模式工作原理:
		 *   双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码。
		 *   双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，
		 * 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。
		 * 
		 * 双亲委派模式优势：
		 *   1.采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。
		 *   2.其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，
		 *     发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改
		 * 
		 * 在JVM中表示两个class对象是否为同一个类对象存在两个必要条件：
		 * 1.类的完整类名必须一致，包括包名。
		 * 2.加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。
		 * 
		 * class文件的显示加载与隐式加载的概念：
		 *   所谓class文件的显示加载与隐式加载的方式是指JVM加载class文件到内存的方式，显示加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。
		 *   而隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。
		 *   在日常开发以上两种方式一般会混合使用，这里我们知道有这么回事即可。
		 * 
		 */
		ClassLoader.getSystemClassLoader();
	}
	
	/**
	 *  
	 * 强引用（Strong Reference）:
	 *   类似 "Object obj = new Object()" 这类的引用，就是强引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。
	 * 软引用（Soft Reference）:
	 *   软引用是用来描述一些有用但并非必需的对象，就是说，内存足够时留着它们，内存即将发生溢出时把这些对象列入回收范围进行回收。若回收过后还没有足够的内存，才抛出内存溢出异常。
	 * 弱引用（Weak Reference）:
	 *   弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些。当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被软引用关联的对象。
	 * 虚引用（Phantom Reference）:
	 *   虚引用也称幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
	 *   
	 * WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。
	 */
	public void learnReference() {
		// WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。
		WeakHashMap<String, String> weakHashMap = new WeakHashMap<>();
	}
}
