package com.zero.j2se.demo;

public class LearnClassLoader {

	/**
	 * 
	 * 类从被加载到虚拟机内存中开始，到卸载出内存，它的整个生命周期包括：
	 * 加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initiallization）、使用（Using）和卸载（Unloading）这7个阶段。
	 * 其中验证、准备、解析3个部分统称为连接（Linking）。
	 * 
	 * 加载(Loading)：
	 *  有两种时机会触发类加载：
	 *  1)预加载。虚拟机启动时加载，加载的是JAVA_HOME/lib/下的rt.jar下的.class文件，这个jar包里面的内容是程序运行时非常常常用到的，像java.lang.*、java.util.*、java.io.*等等，因此随着虚拟机一起加载。
	 *    要证明这一点很简单，写一个空的main函数，设置虚拟机参数为"-XX:+TraceClassLoading"来获取类加载信息。
	 *  2)运行时加载。虚拟机在用到一个.class文件的时候，会先去内存中查看一下这个.class文件有没有被加载，如果没有就会按照类的全限定名来加载这个类。
	 * 
	 *  加载阶段做了三件事:
	 *  1.获取.class文件的二进制流
	 *  2.将类信息、静态变量、字节码、常量这些.class文件中的内容放入方法区中
	 *  3.在内存中生成一个代表这个.class文件的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。一般这个Class是在堆里的，不过HotSpot虚拟机比较特殊，这个Class对象是放在方法区中的
	 *  
	 *  二进制字节流来源:
	 *  1.从zip包中获取，这就是以后jar、ear、war格式的基础
	 *  2.从网络中获取，典型应用就是Applet
	 *  3.运行时计算生成，典型应用就是动态代理技术
	 *  4.由其他文件生成，典型应用就是JSP，即由JSP生成对应的.class文件
	 *  5.从数据库中读取，这种场景比较少见
	 * 
	 * 验证（Verification）:
	 *    这一阶段的目的是为了确保.class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
	 *    Java语言本身是相对安全的语言（相对C/C++来说），但是前面说过，.class文件未必要从Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生.class文件。在字节码语言层面上，Java代码至少从语义上是可以表达出来的。
	 *    虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。
	 *  验证阶段将做以下几个工作：
	 *  1.文件格式检查。class文件的第5~第8个字节表示的是该.class文件的主次版本号，验证的时候会对这4个字节做一个验证，高版本的JDK能向下兼容以前版本的.class文件，但不能运行以后的class文件，即使文件格式未发生任何变化，虚拟机也必须拒绝执行超过其版本号的.class文件。
	 *  2.元数据验证
	 *  3.字节码验证
	 *  4.符号引用验证
	 * 
	 * 准备（Preparation）:
	 *    准备阶段是正式为类变量分配内存并设置其初始值的阶段，这些变量所使用的内存都将在方法区中分配。关于这点，有两个地方注意一下：
	 *    1.这时候进行内存分配的仅仅是类变量（被static修饰的变量），而不是实例变量，实例变量将会在对象实例化的时候随着对象一起分配在Java堆中
	 *    2.这个阶段赋初始值的变量指的是那些不被final修饰的static变量，
	 *      比如"public static int value = 123;"，value在准备阶段过后是0而不是123，给value赋值为123的动作将在初始化阶段才进行；
	 *      比如"public static final int value = 123;"就不一样了，在准备阶段，虚拟机就会给value赋值为123。
	 * 
	 * 解析（Resolution）:
	 *    解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
	 *    符号引用是属于编译原理方面的概念，符号引用包括了下面三类常量：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。符号引用和虚拟机的内存布局是没有关系的，引用的目标未必已经加载到内存中了。
	 *    直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机示例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经存在在内存中了。
	 * 
	 * 初始化（Initiallization）:
	 *    初始化阶段是类加载过程的最后一步，初始化阶段是真正执行类中定义的Java程序代码（或者说是字节码）的过程。初始化过程是一个执行类构造器<clinit>()方法的过程，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。
	 * 把这句话说白一点，其实初始化阶段做的事就是给static变量赋予用户指定的值以及执行静态代码块。
	 *    注意一下，虚拟机会保证类的初始化在多线程环境中被正确地加锁、同步，即如果多个线程同时去初始化一个类，那么只会有一个类去执行这个类的<clinit>()方法，其他线程都要阻塞等待，直至活动线程执行<clinit>()方法完毕。
	 * 因此如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个进程阻塞。不过其他线程虽然会阻塞，但是执行<clinit>()方法的那条线程退出<clinit>()方法后，其他线程不会再次进入<clinit>()方法了，因为同一个类加载器下，一个类只会初始化一次。
	 * 实际应用中这种阻塞往往是比较隐蔽的，要小心。
	 *   Java虚拟机规范严格规定了有且只有5种场景必须立即对类进行初始化，这5种场景也称为对一个类进行主动引用:
	 *   1.使用new关键字实例化对象、读取或者设置一个类的静态字段（被final修饰的静态字段除外）、调用一个类的静态方法的时候
	 *   2.使用java.lang.reflect包中的方法对类进行反射调用的时候
	 *   3.初始化一个类，发现其父类还没有初始化过的时候
	 *   4.虚拟机启动的时候，虚拟机会先初始化用户指定的包含main()方法的那个类
	 *   5.当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic等时
	 *   除了上面5种场景外，所有引用类的方式都不会触发类的初始化，称为被动引用，接下来看下被动引用的几个例子：
	 *   1.子类引用父类静态字段，不会导致子类初始化。至于子类是否被加载、验证了，前者可以通过"-XX:+TraceClassLoading"来查看
	 *   2.通过数组定义引用类，不会触发此类的初始化
	 *   3.引用静态常量时，常量在编译阶段会存入类的常量池中，本质上并没有直接引用到定义常量的类
	 *    
	 * 类加载器： 用户自定义加载器->应用程序加载器->扩展类加载器->启动类加载器。 
	 * 启动（Bootstrap）类加载器：
	 *    启动类加载器主要加载的是JVM自身需要的类，这个类加载使用C++语言实现的，是虚拟机自身的一部分，它负责将 <JAVA_HOME>/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中，
	 * 注意必由于虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的(出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类)。   
	 * 
	 * 扩展（Extension）类加载器：
	 *    扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由Java语言实现的，是Launcher的静态内部类，它负责加载<JAVA_HOME>/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库，
	 * 开发者可以直接使用标准扩展类加载器。
	 *    
	 * 系统（System）类加载器：
	 *    也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。它负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库，也就是我们经常用到的classpath路径，开发者可以直接使用系统类加载器，
	 * 一般情况下该类加载是程序中默认的类加载器，通过ClassLoader.getSystemClassLoader()方法可以获取到该类加载器。 
	 * 
	 * 双亲委派模式工作原理:
	 *   双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码。
	 *   双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，
	 * 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。
	 * 
	 * 双亲委派模式优势：
	 *   1.采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。
	 *   2.其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，
	 *     发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改
	 * 
	 * 在JVM中表示两个class对象是否为同一个类对象存在两个必要条件：
	 * 1.类的完整类名必须一致，包括包名。
	 * 2.加载这个类的ClassLoader(指ClassLoader实例对象)必须相同。
	 * 
	 * class文件的显示加载与隐式加载的概念：
	 *   所谓class文件的显示加载与隐式加载的方式是指JVM加载class文件到内存的方式，显示加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。
	 *   而隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。
	 *   在日常开发以上两种方式一般会混合使用，这里我们知道有这么回事即可。
	 * 
	 */
	public static void useClassLoader() {
		ClassLoader.getSystemClassLoader();
	}
}
