/*
  索引可以加快数据库的检索速度
  表经常进行INSERT/UPDATE/DELETE操作就不要建立索引了，换言之：索引会降低插入、删除、修改等维护任务的速度。
  索引需要占物理和数据空间。
  索引的最左匹配原则
  聚集索引和非聚集索引
 Mysql支持Hash索引和B+树索引两种
 
 基础知识:
 Mysql的基本存储结构是页.各个数据页可以组成一个双向链表.而每个数据页中的记录又可以组成一个单向链表.每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录.
   以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。
 
 不带索引的查找步骤：
 1.定位到记录所在的页
 2.需要遍历双向链表，找到所在的页
 3.从所在的页内中查找相应的记录
 4.由于不是根据主键查询，只能遍历所在页的单链表了
 
 索引提高检索速度原理：
 1.其实就是将无序的数据变成有序(相对)，其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。
 
 BTree索引：
 B+树是平衡树的一种。它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。如果一棵普通的树在极端的情况下，是能退化成链表的(树的优点就不复存在了)。
 B+树是平衡树的一种，是不会退化成链表的，树的高度都是相对比较低的(基本符合矮矮胖胖(均衡)的结构)【这样一来我们检索的时间复杂度就是O(logn)】
 B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会破坏它的原有结构。要维持平衡树，就必须做额外的工作。正因为这些额外的工作开销，导致索引会降低增删改的速度
 
  哈希索引：
         哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。
  限制：
  1.哈希索引也没办法利用索引完成排序
  2.不支持最左匹配原则
  3.在有大量重复键值情况下，哈希索引的效率也是极低的---->哈希碰撞问题。
  4.不支持范围查询
  
  聚集和非聚集索引：聚集索引就是以主键创建的索引，非聚集索引就是以非主键创建的索引。
  聚集索引在建立的时候也未必是单列的，可以多个列来创建索引。此时就涉及到了哪个列会走索引，哪个列不走索引的问题了，索引会遵循最左匹配原则。创建多个单列(非聚集)索引的时候，会生成多个索引树(所以过多创建索引会占用磁盘空间)。
  
  在创建多列索引中也涉及到了一种特殊的索引，覆盖索引。如果不是聚集索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！
  
  索引最左匹配原则：
  索引可以简单如一个列(a)，也可以复杂如多个列(a, b, c, d)，即联合索引。
  如果是联合索引，那么key也由多个列组成，同时，索引只能用于查找key是否存在（相等），遇到范围查询(>、<、between、like左匹配)等就不能进一步匹配了，后续退化为线性查找。
  因此，列的排列顺序决定了可命中索引的列数。
  
  最左前缀匹配原则：MySQL会一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE）就停止匹配。
  尽量选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col) / COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。
  索引列不能参与计算，尽量保持列“干净”。
  尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
  单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引。
  
  
   锁：
   在mysql中的锁看起来是很复杂的，因为有一大堆的东西和名词：排它锁，共享锁，表锁，页锁，间隙锁，意向排它锁，意向共享锁，行锁，读锁，写锁，乐观锁，悲观锁，死锁。这些名词有的博客又直接写锁的英文的简写--->X锁，S锁，IS锁，IX锁，MMVC...
 
   对于UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)
 MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预
 
 InnoDB行锁和表锁都支持！InnoDB只有通过索引条件检索数据才使用行级锁，否则，InnoDB将使用表锁。也就是说，InnoDB的行锁是基于索引的！
 MyISAM只支持表锁！
 
 表锁下又分为两种模式：表读锁（Table Read Lock）、表写锁（Table Write Lock）
 读读不阻塞：当前用户在读数据，其他的用户也在读数据，不会加锁
 读写阻塞：当前用户在读数据，其他的用户不能修改当前用户读的数据，会加锁！
 写写阻塞：当前用户在修改数据，其他的用户不能修改当前用户正在修改的数据，会加锁！
 
 读锁和写锁是互斥的，读写操作是串行。如果某个进程想要获取读锁，同时另外一个进程想要获取写锁。在mysql里边，写锁是优先于读锁的！写锁和读锁优先级的问题是可以通过参数调节的：max_write_lock_count和low-priority-updates
 
 MyISAM可以支持查询和插入操作的并发进行，但是InnoDB存储引擎是不支持的！
 
 丢失更新：一个事务的更新覆盖了其它事务的更新结果。
 
 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新。
 悲观锁是数据库层面加锁，都会阻塞去等待锁。
 
 
 */
ALTER TABLE `xshop_goods`
ADD INDEX ` idx_product_id` (`product_id`) USING BTREE ;

